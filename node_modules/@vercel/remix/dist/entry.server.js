/**
 * @vercel/remix v2.10.0
 *
 * Copyright (c) Vercel, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var stream = require('stream');
var server = require('react-dom/server');
var isbot = require('isbot');
var node = require('@remix-run/node');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isbot__default = /*#__PURE__*/_interopDefaultLegacy(isbot);

const ABORT_DELAY = 5000;
function handleRequest(request, responseStatusCode, responseHeaders, remixServer) {
  // If the request is from a bot, we want to wait for the full
  // response to render before sending it to the client. This
  // ensures that bots can see the full page content.
  if (isbot__default["default"](request.headers.get("user-agent"))) {
    return serveTheBots(responseStatusCode, responseHeaders, remixServer);
  }
  return serveBrowsers(responseStatusCode, responseHeaders, remixServer);
}
function serveTheBots(responseStatusCode, responseHeaders, remixServer) {
  return new Promise((resolve, reject) => {
    let {
      pipe,
      abort
    } = server.renderToPipeableStream(remixServer, {
      // Use onAllReady to wait for the entire document to be ready
      onAllReady() {
        responseHeaders.set("Content-Type", "text/html");
        let body = new stream.PassThrough();
        let stream$1 = node.createReadableStreamFromReadable(body);
        resolve(new Response(stream$1, {
          status: responseStatusCode,
          headers: responseHeaders
        }));
        pipe(body);
      },
      onShellError(err) {
        reject(err);
      }
    });
    setTimeout(abort, ABORT_DELAY);
  });
}
function serveBrowsers(responseStatusCode, responseHeaders, remixServer) {
  return new Promise((resolve, reject) => {
    let didError = false;
    let {
      pipe,
      abort
    } = server.renderToPipeableStream(remixServer, {
      // use onShellReady to wait until a suspense boundary is triggered
      onShellReady() {
        responseHeaders.set("Content-Type", "text/html");
        let body = new stream.PassThrough();
        let stream$1 = node.createReadableStreamFromReadable(body);
        resolve(new Response(stream$1, {
          status: didError ? 500 : responseStatusCode,
          headers: responseHeaders
        }));
        pipe(body);
      },
      onShellError(err) {
        reject(err);
      },
      onError(err) {
        didError = true;
        console.error(err);
      }
    });
    setTimeout(abort, ABORT_DELAY);
  });
}

exports.handleRequest = handleRequest;
